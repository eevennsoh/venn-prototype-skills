---
alwaysApply: true
---

# Framer Code Rules

You are an expert in Framer, React, TypeScript, and Framer Motion. Follow these rules to generate high-quality, robust, and performant Framer code.

## 1. Core Principles

- **Type Safety**: Always use TypeScript. Define interfaces for Props and State.
- **Performance**: Use `memo`, `useMemo`, and `useCallback` to prevent unnecessary re-renders.
- **Resilience**: Handle loading states, errors, and edge cases (e.g., missing props).
- **Accessibility**: Ensure components are accessible (ARIA attributes, keyboard navigation).
- **Framer Native**: Use Framer's specific APIs (`addPropertyControls`, `ControlType`, `RenderTarget`) effectively.

## 2. Component Types & Templates

### Code Components

Use for creating new, reusable UI elements with custom logic.

**Basic Template:**

```tsx
import { addPropertyControls, ControlType } from "framer";
import { motion } from "framer-motion";

interface ComponentNameProps {
	text: string;
	style?: React.CSSProperties;
}

/**
 * @framerIntrinsicWidth 200
 * @framerIntrinsicHeight 200
 * @framerDisableUnlink
 */
export default function MyComponent(props: ComponentNameProps) {
	const { text, style } = props;

	return <motion.div style={{ ...style }}>{text}</motion.div>;
}

MyComponent.defaultProps = {
	text: "Hello World",
};

addPropertyControls(MyComponent, {
	text: { type: ControlType.String, title: "Text" },
});
```

### Code Overrides

Use to inject logic, state, or styles into existing Canvas elements.

**Basic Template:**

```tsx
import type { ComponentType } from "react";

export function withHoverEffect(Component): ComponentType {
	return (props) => {
		return <Component {...props} whileHover={{ scale: 1.1 }} />;
	};
}
```

### Metadata & Exports

- Declare `@framerIntrinsicWidth`, `@framerIntrinsicHeight`, `@framerSupportedLayoutWidth/Height`, and `@framerDisableUnlink` immediately before the component so layout expectations stay in sync between canvas and runtime.
- Always provide `defaultProps`, and keep the values that property controls expose in lockstep with those defaults.
- Keep `addPropertyControls` adjacent to the component to make maintenance easier; when you add a new prop, update both the interface/defaults and its control entry in one place.

## 3. Property Controls

## Maximize configurability using `addPropertyControls` for a polished experience.

### Core Principles

- **Granularity**: Expose all visual styles (colors, padding, radius, shadows) using their specific ControlTypes.
- **Grouping**: Use `ControlType.Object` to group related props (e.g., `styleObject`, `animObject`) to keep the UI clean.
- **Clarity**: Use clear titles (Sentence case), sensible `defaultValue`s, and `description` fields.
- **Connectivity**: Use `ComponentInstance` for slots and `Array` for lists or multiple connections.

### Steps to add property controls

1. Use Context7 to reference the latest Framer documentation on Property Controls and Auto-Sizing:

- https://www.framer.com/developers/property-controls
- https://www.framer.com/developers/auto-sizing

2. Audit the code for comprehensive property exposure:

- **Analyze the component code** to identify all visual styles, animation properties, and expose them as controls.
- Ensure specific property uses their dedicated ControlTypes:
  - `ControlType.Color`: For any color properties (backgrounds, text, fills).
  - `ControlType.Padding`: For spacing inside containers.
  - `ControlType.BorderRadius`: For corner rounding.
  - `ControlType.BoxShadow`: For drop shadows and inner shadows.
  - `ControlType.Border`: For border width, color, and style.
  - `ControlType.Cursor`: For hover interactions (e.g., `pointer`, `grab`).
  - `ControlType.Link`: For any interactive elements requiring navigation.
  - `ControlType.Date`: For any timestamp or calendar data.
  - `ControlType.Transition`: For animations and transitions, or grouped objects with `icon: "effect"`.

3. Leverage connectivity and lists with `Array` and `ComponentInstance`:

- Use `ControlType.ComponentInstance` to allow connecting to other Frames on the canvas (e.g., for content slots, overlays, or navigation targets).
- Use `ControlType.Array` wrapping `ControlType.ComponentInstance` when multiple connections are needed (e.g., carousels, grids, feeds).
- Use `ControlType.Array` for iterating over data lists (e.g., feature lists, testimonials, menu items).

4. Refine control definitions and grouping:

- Group logically related properties (e.g. padding, radius, icons) into `Object` controls for a tidy, nested UI.
  - Add an optional `icon` property (e.g., "color", "effect", "interact") to `Object` controls for better visual recognition.
- Ensure hidden callbacks correctly reference nested props (e.g. `hidden: (props) => !props.snapObject?.snap`).
- Prefer `Enum` controls using `displaySegmentedControl: true` for directional, toggle, or choice-based props.
- Use `optionIcons` for `Enum` controls to improve alignment and directional controls (e.g., for vertical alignment `align-top`, `align-middle`, `align-bottom`) and (e.g., for horizontal alignment `align-left`, `align-center`, `align-right`).
- Replace dropdown enums with `segmentedControlDirection: vertical` where multiple visual options fit better vertically.
- Prefer `ControlType.ResponsiveImage` over `ControlType.Image` for better asset optimization and handling.

5. Refactor for clarity and consistency:

- Use `ControlType.Font` with `controls: "extended"` or `displayFontSize: true` for comprehensive typography settings.
- Group Font and Color controls into a single `styleObject` or `fontObject` if they change together.
- Keep text content (`title`, `label`, `value`, `placeholder`) as top-level controls for easier variable binding.
- Use spread syntax (e.g., `...paddingControl`, `...radiusControl`) from shared utilities for consistent standard controls.
- Move layout-related props (sizing, snapping, alignment) into dedicated grouped objects.

6. Enhance user experience and polish:

- Use `optional: true` for aesthetic or advanced groups (e.g. shadows, animation).

  - Ensure all property controls provide smart `defaultValue`s that reflect the component's intended initial state.
  - Eliminate `defaultProps`. Define default values in the component's destructured props and ensure the `defaultValue` in `addPropertyControls` matches it.
  - Add sensible `defaultValue`, `min`, `max`, and `unit` fields for all numeric controls.
  - Use `displayStepper: true` for `ControlType.Number` when the range is small (e.g. 0-10) to allow easy incrementing.
  - Add a `description` property to the _last_ property control in the list to include a brief description of this code component.

- Ensure naming consistency and clean UI presentation:
  - Ensure property control keys use camelCase (e.g. `tagTheme`) for clean code references.
  - Use sentence case for the `title` field (e.g. `Tag theme`) to ensure readability in the Framer UI.
  - Make sure the label use in camelCase are exactly the same as the sentence case (e.g. `tagTheme` vs `Tag theme`). The only difference is camelCase doesn't have the spacing.
- Use TypeScript Enums and `Object.values()` for `Enum` options to ensure type safety and reduce duplication.
- Maintain alphabetic order or logical visual grouping in property registration.

7. Validate component layout responsiveness:

- Confirm the component respects `auto`, `stretch`, and `fixed` sizing behaviors.
- Apply proper Framer auto-sizing configuration to support both “hug” and “fill” scenarios.
- Verify auto-sizing annotations (`@framerSupportedLayoutWidth`, `@framerSupportedLayoutHeight`) match component intent.

### Comprehensive Example

```tsx
import { addPropertyControls, ControlType } from "framer";

addPropertyControls(MyComponent, {
	// 1. Content & Basics
	title: {
		type: ControlType.String,
		title: "Title",
		defaultValue: "Hello World",
		placeholder: "Enter title...",
		displayTextArea: true, // Multi-line support
	},
	link: {
		type: ControlType.Link,
		title: "Link",
	},

	// 2. Visual Styles (Use specific ControlTypes)
	color: {
		type: ControlType.Color,
		title: "Color",
		defaultValue: "#0099FF",
	},
	// Prefer ResponsiveImage for better optimization
	image: {
		type: ControlType.ResponsiveImage,
		title: "Image",
		allowedFileTypes: ["jpg", "png", "svg"],
	},

	// 3. Layout & Spacing (Grouped)
	layout: {
		type: ControlType.Object,
		title: "Layout",
		controls: {
			padding: { type: ControlType.Padding, title: "Padding", defaultValue: 20 },
			radius: { type: ControlType.BorderRadius, title: "Radius", defaultValue: 8 },
			gap: {
				type: ControlType.Number,
				title: "Gap",
				min: 0,
				max: 100,
				displayStepper: true,
				defaultValue: 10,
			},
		},
	},

	// 4. Typography (Extended options)
	font: {
		type: ControlType.Font,
		title: "Typography",
		controls: "extended", // Shows weight, style, etc.
		displayFontSize: true,
		defaultFontType: "sans-serif",
		defaultValue: {
			fontSize: 16,
			lineHeight: "1.4em",
		},
	},

	// 5. Interactive & Advanced Groups
	interaction: {
		type: ControlType.Object,
		title: "Interaction",
		icon: "interact", // "color" | "effect" | "interact"
		controls: {
			cursor: {
				type: ControlType.Cursor,
				title: "Cursor",
				defaultValue: "pointer",
			},
			onTap: { type: ControlType.EventHandler },
			hover: {
				type: ControlType.Boolean,
				title: "Hover Effect",
				enabledTitle: "On",
				disabledTitle: "Off",
				defaultValue: true,
			},
		},
	},

	// 6. Enums with Icons (Visual choices)
	align: {
		type: ControlType.Enum,
		title: "Align",
		options: ["left", "center", "right"],
		optionIcons: ["align-left", "align-center", "align-right"],
		displaySegmentedControl: true,
		defaultValue: "center",
	},

	// 7. Lists & Connections
	items: {
		type: ControlType.Array,
		title: "List Items",
		control: {
			type: ControlType.Object,
			controls: {
				title: { type: ControlType.String },
				date: { type: ControlType.Date },
				icon: { type: ControlType.Icon },
			},
		},
		maxCount: 6,
	},
	slots: {
		type: ControlType.Array,
		title: "Children",
		control: { type: ControlType.ComponentInstance },
		maxCount: 5,
	},

	// 8. Effects & Transitions
	effect: {
		type: ControlType.Object,
		title: "Effect",
		icon: "effect",
		optional: true, // Adds a toggle switch for the whole group
		controls: {
			shadow: {
				type: ControlType.BoxShadow,
				title: "Shadow",
				defaultValue: "0px 2px 4px rgba(0,0,0,0.1)",
			},
			transition: {
				type: ControlType.Transition,
				title: "Transition",
			},
		},
	},
});
```

## 4. Layout & Auto-Sizing

Correctly handle sizing to ensure components behave predictably on the canvas.

- **Fixed Size**:
  ```tsx
  /**
   * @framerSupportedLayoutWidth fixed
   * @framerSupportedLayoutHeight fixed
   */
  ```
- **Auto Size (Content-based)**:
  ```tsx
  /**
   * @framerSupportedLayoutWidth auto
   * @framerSupportedLayoutHeight auto
   */
  ```
- **Any (User choice)**:
  ```tsx
  /**
   * @framerSupportedLayoutWidth any
   * @framerSupportedLayoutHeight any
   */
  ```

**Measuring Content:**
Use `useMeasuredSize` for components that need to react to their container size.

```tsx
import { useMeasuredSize } from "framer";
// inside component
const ref = useRef(null);
const { measured } = useMeasuredSize(ref);
// measured.width, measured.height
```

## 5. Best Practices & Patterns

### Styles & Props

- **Define Props Interface**: Always define a TypeScript interface for your component props (e.g., `interface Props { ... }`) to ensure type safety and better tooling support.
- **ALWAYS spread `style`**: `<div style={{ ...props.style, backgroundColor: "red" }} />`
- **Destructure Props**: Keep code clean. `const { text, tint, style } = props`

### State Management

Use `createStore` for shared state across overrides.

```tsx
import { createStore } from "https://framer.com/m/framer/store.js@^1.0.0";
const useStore = createStore({ count: 0 });
```

### Documentation & Comments

- **Brief Descriptions**: Always add a brief comment or description to explain the purpose of sections, functions, or complex logic blocks.

### Performance

- **Animations**: Use `layoutId` for shared element transitions. Use `useAnimation` for imperative control.
- **Imports**: Import lightweight assets.
- **Render Context Detection**: Use `RenderTarget` to detect where your component is being rendered and optimize accordingly.
- **Framer Motion API**: The entire Motion for React API is available in every Code Component via `framer-motion`.

```tsx
import { animate, motion } from "framer-motion";
```

#### RenderTarget API

Use `RenderTarget` to detect the current rendering context and conditionally enable/disable features:

```tsx
import { RenderTarget } from "framer";

const isOnCanvas = RenderTarget.current() === RenderTarget.canvas;
const isExport = RenderTarget.current() === RenderTarget.export;
const isPreview = RenderTarget.current() === RenderTarget.preview;
const isThumbnail = RenderTarget.current() === RenderTarget.thumbnail;
```

**Available RenderTarget types:**

- `RenderTarget.canvas` — The Canvas
- `RenderTarget.export` — The Export Canvas
- `RenderTarget.thumbnail` — Project Thumbnails
- `RenderTarget.preview` — The Preview or live site

#### Static Rendering for Animated Components

For components with animations (WebGL shaders, continuous animations, particles), use `useIsStaticRenderer()` instead of `RenderTarget` to ensure static rendering on both Canvas and Export. This prevents performance issues and export artifacts like tiling.

```tsx
import { useIsStaticRenderer } from "framer";

export default function AnimatedComponent(props) {
	const isStaticRenderer = useIsStaticRenderer();

	// Disable animations on Canvas and during Export
	if (isStaticRenderer) {
		return <StaticVersion {...props} />;
	}

	return <AnimatedVersion {...props} />;
}
```

**Use cases for static rendering:**

- WebGL shaders and canvas animations
- Continuous motion animations
- Particle systems
- Heavy visual effects that cause performance issues on Canvas
- Components that animate during export causing tiling issues

### Scoped Styling & Theming

- Use `withCSS` to scope component-level styles and to inject accessibility helpers (screen-reader labels, focus outlines, hover states). Keep CSS snippets colocated with the component so they travel with the bundle.
- Compose helper hooks such as `getPaddingStyle`, `getRadiusStyle`, `getBorderStyle`, and `usePadding` behind property controls. This ensures padding, radius, hover, and focus tokens always reflect the control panel.
- Prefer CSS custom properties for theme tokens (e.g., `--framer-background-color`) so overrides propagate without prop drilling.

### Accessibility

- Use semantic HTML tags (`button`, `nav`, `main`) when possible and pair inputs/selects with a hidden `<label>` via `useId`.
- Provide `aria-label`s for icon-only triggers, increase tap targets with pseudo-elements, and keep focus styles visible via CSS (`:focus-visible` or scoped `withCSS` helpers).
- Prevent unwanted autofill (`autoComplete="off"` on locale/search inputs) and maintain keyboard parity with pointer behavior, including ESC/Enter handlers on overlays or modals.
- Default colors should meet contrast requirements; expose palette controls when possible so designers can adjust values directly in the canvas.

### Environment Awareness & Responsiveness

- Detect the runtime with `RenderTarget`, `useIsOnCanvas`, `useIsInCurrentNavigationTarget`, or `useIsInPreview` before touching DOM APIs, portals, or playback-heavy logic.
- Use viewport or intersection hooks (`useViewportSizeState`, `useInView`) to lazy-load heavy experiences (search overlays, autoplay video) and adapt layout types responsively.
- Persist navigation-specific playback or focus state with `useOnEnter`/`useOnExit` when prototyping flows that move across pages.

### Animation & Interaction Guidelines

- **Motion Documentation**: Use the Motion MCP server to access the latest [Motion for React documentation](https://motion.dev/docs/react) when building animations. This ensures you're using current best practices and APIs for animation, gestures, scroll effects, and advanced features.
- Capture animation settings with `ControlType.Transition` or object controls so designers can tune easing, repeat, and delays without editing code (ColorCycle, Search modal, Video).
- Use `motion` primitives with variant maps or arrays for predictable sequencing (`animate={{ backgroundColor: [...] }}` in ColorCycle, `AnimatePresence` for Search overlays).
- Provide escape hatches (`ESC` listeners, overlay dismissal, `blurOnSubmit`) and clean up timers/intervals to keep interactions resilient (`Countdown`, `Search`, `Video`).

## 6. Checklist Before Finalizing

### Code Structure & Types

1. [ ] TypeScript interface defined for component props?
2. [ ] Are imports correct? (`framer` vs `framer-motion`)
3. [ ] Is the component exported as `default`?
4. [ ] Is `style` prop spread correctly in the component?

### Property Controls

5. [ ] Are Property Controls defined for all configurable props?
6. [ ] Do Property Controls use specific ControlTypes (`Color`, `Padding`, `BorderRadius`, `BoxShadow`, etc.) instead of generic numbers/strings?
7. [ ] Are related props grouped using `ControlType.Object`?
8. [ ] Do `Enum` controls use `optionIcons` and Objects use `icon` property for visual recognition?
9. [ ] Do all controls have appropriate `defaultValue`s (not using `defaultProps`)?
10. [ ] Are numeric controls configured with sensible `min`, `max`, and `step` values?
11. [ ] Are property control keys in camelCase and titles in Sentence case?
12. [ ] Is there a `description` on the last property control?
13. [ ] Are conditional controls using `hidden: (props) => ...` where appropriate?

### Layout & Sizing

14. [ ] Are layout annotations correct (`@framerSupportedLayoutWidth/Height`)?
15. [ ] Are intrinsic size annotations provided (`@framerIntrinsicWidth/Height`)?
16. [ ] Does the component handle `auto`, `fixed`, and `any` sizing appropriately?

### Performance & Environment

17. [ ] Are heavy components wrapped in `React.memo`?
18. [ ] Is `RenderTarget` or `useIsStaticRenderer()` used for environment-aware rendering?
19. [ ] Are animations optimized (static on Canvas/Export if needed)?

### Accessibility & UX

20. [ ] Are semantic HTML tags used (`button`, `nav`, `main`)?
21. [ ] Are ARIA attributes included where needed?
22. [ ] Is keyboard navigation supported?
23. [ ] Do colors meet contrast requirements?
24. [ ] Are focus states visible?

### Interaction & Animation

25. [ ] Are escape hatches provided (ESC listeners, dismissal)?
26. [ ] Are timers and intervals cleaned up properly?
27. [ ] Are animation settings exposed via Property Controls?
